#version 460
layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

// Binding 0: Output Image
layout(binding = 0, rgba8) uniform image2D resultImage;

<<<<<<< Updated upstream
// Basic Camera UBO (Placeholder)
layout(binding = 1) uniform Camera {
=======
// --- Structures (Must match C++ alignments) ---

struct Material {
    vec4 color;
    float density; float friction; float restitution; float hardness;
    float health; float flammability; float heatRes; uint flags;
    uint textureIndex; uint soundImpact; uint soundDestroy; uint _pad;
};

struct Object {
    mat4 model;
    mat4 invModel;
    uint chunkIndex;
    uint paletteOffset;
    uint flags;
    uint _pad;
};

// Chunk structure: 32^3 voxels + hierarchy
// 32*32*32 bytes = 32768 bytes (8192 uints)
// Hierarchy mask = 64 bytes (16 uints)
struct Chunk {
    uint voxels[8192];   // Packed 4 bytes per uint -> 4 voxels per uint
    uint hierarchy[16];  // Optimization masks
};

// --- Bindings ---

layout(binding = 1, std140) uniform Camera {
>>>>>>> Stashed changes
    mat4 viewInverse;
    mat4 projInverse;
} cam;

layout(binding = 2, std430) readonly buffer Materials {
    Material materials[];
} matBuffer;

layout(binding = 3, std430) readonly buffer Objects {
    Object objects[];
} objBuffer;

layout(binding = 4, std430) readonly buffer Chunks {
    Chunk chunks[];
} chunkBuffer;

// --- Constants ---
const float MAX_DIST = 1000.0;
const vec3 SKY_COLOR_TOP = vec3(0.2, 0.4, 0.8);
const vec3 SKY_COLOR_BOT = vec3(0.8, 0.9, 1.0);

// --- Intersection Logic ---

// Axis Aligned Bounding Box intersection (Slab method)
bool IntersectAABB(vec3 origin, vec3 dir, vec3 boxMin, vec3 boxMax, out float tNear, out float tFar) {
    vec3 invDir = 1.0 / dir;
    vec3 tbot = invDir * (boxMin - origin);
    vec3 ttop = invDir * (boxMax - origin);

    vec3 tmin = min(ttop, tbot);
    vec3 tmax = max(ttop, tbot);

    vec2 t = max(tmin.xx, tmin.yz);
    float t0 = max(t.x, t.y);
    t = min(tmax.xx, tmax.yz);
    float t1 = min(t.x, t.y);

    tNear = t0;
    tFar = t1;

    return t1 > max(t0, 0.0);
}

// Helper to unpack voxel ID from uint array
uint GetVoxel(uint chunkIdx, ivec3 pos) {
    // Check bounds
    if (pos.x < 0 || pos.x >= 32 || pos.y < 0 || pos.y >= 32 || pos.z < 0 || pos.z >= 32) return 0;
    
    // Linear index
    uint index = pos.x + pos.y * 32 + pos.z * 32 * 32;
    uint arrayIdx = index / 4; // 4 voxels per uint
    uint byteOffset = (index % 4) * 8; // 8 bits per voxel
    
    uint packedData = chunkBuffer.chunks[chunkIdx].voxels[arrayIdx];
    return (packedData >> byteOffset) & 0xFF; // Extract byte
}

void main() {
    ivec2 texelCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(resultImage);

<<<<<<< Updated upstream
    if (texelCoord.x >= size.x || texelCoord.y >= size.y) {
        return;
    }

    // Normalized Device Coordinates (-1 to 1)
    vec2 uv = (vec2(texelCoord) / vec2(size)) * 2.0 - 1.0;

    // Simple gradient for testing Compute Shader dispatch
    vec4 color = vec4(uv.x * 0.5 + 0.5, uv.y * 0.5 + 0.5, 0.0, 1.0);

    // TODO: Ray generation & Beam Optimization logic here
    // vec3 origin = (cam.viewInverse * vec4(0,0,0,1)).xyz;
    // vec3 target = (cam.projInverse * vec4(uv.x, uv.y, 1, 1)).xyz;
    // vec3 dir = normalize((cam.viewInverse * vec4(target, 0)).xyz);

    imageStore(resultImage, texelCoord, vec4(0.5,0.2,0.3,1));
=======
    if (texelCoord.x >= size.x || texelCoord.y >= size.y) return;

    // --- 1. Ray Generation ---
    vec2 uv = (vec2(texelCoord) + 0.5) / vec2(size);
    vec2 ndc = uv * 2.0 - 1.0; // Map to -1..1

    // Unproject
    vec4 target = cam.projInverse * vec4(ndc.x, ndc.y, 1.0, 1.0);
    vec4 direction = cam.viewInverse * vec4(normalize(target.xyz / target.w), 0.0);
    
    vec3 rayOrigin = cam.position.xyz;
    vec3 rayDir = normalize(direction.xyz);

    // --- 2. Ray Casting (Scene Traversal) ---
    float closestT = MAX_DIST;
    vec3 finalColor = mix(SKY_COLOR_TOP, SKY_COLOR_BOT, uv.y); // Sky Gradient
    
    // Iterate over all objects
    for(int i = 0; i < int(cam.objectCount); i++) {
        Object obj = objBuffer.objects[i];

        // Transform Ray to Local Space of the Object
        // Using matrix multiplication for origin (point) and direction (vector)
        vec3 localOrigin = (obj.invModel * vec4(rayOrigin, 1.0)).xyz;
        vec3 localDir = normalize((obj.invModel * vec4(rayDir, 0.0)).xyz);

        // Check AABB intersection against Chunk bounds (0,0,0 to 32,32,32)
        float tNear, tFar;
        if (IntersectAABB(localOrigin, localDir, vec3(0.0), vec3(32.0), tNear, tFar)) {
            
            // If we hit the box, check if it's closer than current hit
            // In a full implementation, we would run DDA here to find the exact voxel.
            // For now, we visualize the bounding box hit.
            if (tNear < closestT && tNear > 0.0) {
                closestT = tNear;
                
                // Debug Visualization:
                // Color based on local normal at hit point (simplified)
                vec3 hitPos = localOrigin + localDir * tNear;
                vec3 center = vec3(16.0);
                vec3 normal = normalize(hitPos - center); // Approximation for sphere-like, box needs slab logic
                
                // Make it look like a box:
                vec3 boxNormal = step(vec3(0.99), abs(normal)) * sign(normal); // Very rough box normal approximation
                
                // Read material color from palette (just taking index 1 for test)
                vec4 matColor = matBuffer.materials[1].color; 
                
                // Simple shading
                float light = max(dot(normal, normalize(vec3(1, 2, 3))), 0.2);
                finalColor = matColor.rgb * light;
                
                // OPTIONAL: Voxel Sampling Test (Center voxel)
                // uint voxelID = GetVoxel(obj.chunkIndex, ivec3(16, 16, 16));
                // if (voxelID > 0) finalColor += vec3(0.2);
            }
        }
    }

    imageStore(resultImage, texelCoord, vec4(finalColor, 1.0));
>>>>>>> Stashed changes
}