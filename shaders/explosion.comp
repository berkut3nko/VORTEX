#version 460
layout(local_size_x = 4, local_size_y = 4, local_size_z = 4) in;

// Reuse structures from raytracing
struct GridCell {
    uint brickIndex;
    uint metadata;
};

struct Brick {
    uint packedVoxels[128]; 
};

layout(binding = 0, std430) buffer IndirectionGrid {
    GridCell cells[];
} gridBuffer;

layout(binding = 1, std430) buffer BrickPool {
    Brick bricks[];
} poolBuffer;

// Parameters for the explosion
layout(push_constant) uniform PushConsts {
    vec3 center;    // Global coordinates (0..256 in grid units)
    float radius;   // Radius in grid units (e.g., 0.5 = 4 voxels)
    uint val;       // Value to set (0 for destruction, >0 for building)
} params;

// Constants
const uint GRID_DIM = 256;
const uint BRICK_SIZE = 8;

void SetVoxel(uint brickIdx, ivec3 localPos, uint val) {
    uint idx = localPos.x + localPos.y * BRICK_SIZE + localPos.z * BRICK_SIZE * BRICK_SIZE;
    uint uintIdx = idx / 4;
    uint shift = (idx % 4) * 8;
    uint mask = ~(0xFF << shift);
    
    // Atomic operations are safer but slower. 
    // Since we are mostly destroying, standard read-modify-write might have race conditions
    // at the edges of workgroups, but for visual FX it's acceptable usually.
    // For strict correctness, use atomicAnd / atomicOr.
    
    uint current = poolBuffer.bricks[brickIdx].packedVoxels[uintIdx];
    uint newVal = (current & mask) | ((val & 0xFF) << shift);
    poolBuffer.bricks[brickIdx].packedVoxels[uintIdx] = newVal;
}

void main() {
    // Workgroup covers a volume of bricks or voxels? 
    // Let's assume we dispatch this over the AABB of the explosion.
    // Global ID represents absolute voxel coordinate offset from min bounds.
    // This is a simplified kernel that assumes we dispatch threads for VOXELS.
    
    // ... Implementation depends on dispatch strategy ...
    // Let's assume simplified: Dispatch over grid cells affected.
    
    ivec3 id = ivec3(gl_GlobalInvocationID.xyz);
    
    // Map ID to Grid Cell
    // Assuming we calculate bounds on CPU and dispatch only necessary groups.
    // Let's implement a naive "Test Voxel" logic for simplicity.
    
    // TODO: A generic explosion shader needs correct coordinate mapping.
    // For now, this is a template.
}