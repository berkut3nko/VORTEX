#version 460

layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0) uniform sampler2D texColor;
layout(binding = 1) uniform sampler2D texHistory;
layout(binding = 2) uniform sampler2D texVelocity;
layout(binding = 3) uniform sampler2D texDepth;
layout(binding = 4, rgba8) uniform writeonly image2D imgOutput;

void main() {
    ivec2 pixelPos = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(imgOutput);
    if(pixelPos.x >= size.x || pixelPos.y >= size.y) return;

    vec2 uv = (vec2(pixelPos) + 0.5) / vec2(size);
    vec2 texelSize = 1.0 / vec2(textureSize(texColor, 0)); // Get size of input texture

    // 1. Read Current Color
    vec3 color = texture(texColor, uv).rgb;

    // 2. Read Velocity
    vec2 velocity = texture(texVelocity, uv).rg;

    // 3. Reproject to find History UV
    vec2 prevUV = uv - velocity;

    // 4. Check if history is valid (inside screen)
    if(prevUV.x < 0.0 || prevUV.x > 1.0 || prevUV.y < 0.0 || prevUV.y > 1.0) {
        imageStore(imgOutput, pixelPos, vec4(color, 1.0));
        return;
    }

    // 5. Read History
    vec3 history = texture(texHistory, prevUV).rgb;

    // 6. Neighborhood Clamping (Anti-Ghosting)
    vec3 minColor = color;
    vec3 maxColor = color;
    
    // FIX: Use texture() with calculated UVs instead of textureOffset()
    // This avoids "argument must be compile-time constant" error
    for(int x = -1; x <= 1; x++) {
        for(int y = -1; y <= 1; y++) {
            if(x == 0 && y == 0) continue; // Skip center (already have it)
            
            vec2 sampleUV = uv + vec2(x, y) * texelSize;
            vec3 neighbor = texture(texColor, sampleUV).rgb;
            
            minColor = min(minColor, neighbor);
            maxColor = max(maxColor, neighbor);
        }
    }
    
    // Clamp history
    history = clamp(history, minColor, maxColor);

    // 7. Blend
    float blend = 0.9;
    vec3 result = mix(color, history, blend);

    imageStore(imgOutput, pixelPos, vec4(result, 1.0));
}